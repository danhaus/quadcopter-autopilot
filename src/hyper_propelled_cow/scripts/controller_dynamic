#!/usr/bin/env python

import rospy
import time
from std_msgs.msg import Int16, Int32

import propelled_cow.PID_control as _PID


class Controller(object):
	"""docstring for Controller"""
	def __init__(self):
		self.distance_demand = rospy.get_param('distance_treshold')
		self.PID_vals = rospy.get_param('distance')
		self.controller = _PID.PID(self.PID_vals['Kp'], self.PID_vals['Ki'], self.PID_vals['Kd'], 2, 0) # THE LAST TWO VALUES NEEDS TO BE ADJUSTED
		self.throttle_pub = rospy.Publisher('PWM_throttle', Int16, queue_size=2)
		self.servo_pub = rospy.Publisher('servo_angle', Int16, queue_size=10)
		rospy.init_node('controller', anonymous=True)
		self.PWM_limits = rospy.get_param('PWM')
		self.PWM_current = self.PWM_limits['min']

		# is_in_the_air() vars
		self.votes_count = 0

		# take_off() vars
		self.PWM_dynamic_min = 1000
		self.PWM_dynamic_max = 1000

		# Start countdown.
		i = 10
		rospy.logwarn("Take off counter started.")
		while (i > 0):
			rospy.logwarn("Countdown: " + str(i))
			time.sleep(1)
			i = i - 1
		rospy.logwarn("Launched.")

		self.start = time.time()

		# Take off.
		self.take_off()

		# Start PID controlled flight.
		rospy.Subscriber('distance_fused', Int16, self.main_control)
		rospy.spin() # IT MIGHT NOT NEED TO BE HERE

	def is_in_the_air(self, altitude):
		if altitude > 100:
			self.votes_count += 1
			rospy.loginfo("votes_count: " + str(self.votes_count))
			if self.votes_count >= 10:
				return True
		else:
			self.votes_count = 0
		return False

	def take_off(self):
		PWM_dynamic_current = self.PWM_limits['dynamic_start']
		PWM_dynamic_range = self.PWM_limits['dynamic_range']
		sleep_time = 0.5
		PWM_delta = 5
		while(not self.is_in_the_air()): # while it is on the ground
			PWM_dynamic_current += PWM_delta
			self.throttle_pub.publish(PWM_dynamic_current)
			time.sleep(sleep_time)
		# Now set the limits to the class vars
		self.PWM_dynamic_min = int(PWM_dynamic_current - PWM_dynamic_range/2)
		self.PWM_dynamic_max = int(PWM_dynamic_current + PWM_dynamic_range/2)

	def main_control(self, data):
		self.distance = data.data
		err = self.distance_demand - self.distance
		PWM_correction = -self.controller.update_PID(err)
		PWM_raw = self.PWM_current + PWM_correction
		self.PWM_current = _PID.saturation(PWM_raw, self.PWM_limits['min'], self.PWM_limits['max'])
		self.throttle_pub.publish(self.PWM_current)

		# drop the bean bag if the drone is higher than 700 mm and the autopilot runs for at lest 10 secs
		if (self.distance >= (self.distance_demand - 100 )): # if the drone is higher than 800 - 100 mm
			now = time.time()
			if (now - self.start > 10): # if the drone is in the air for more than 10 secs
				self.servo_pub.publish(170)

if __name__ == '__main__':
	controller = Controller()
